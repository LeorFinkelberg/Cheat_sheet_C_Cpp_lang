\documentclass[%
	11pt,
	a4paper,
	utf8,
	%twocolumn
		]{article}	

\usepackage{style_packages/podvoyskiy_article_extended}


\begin{document}
\title{Приемы программирования на языках C и C++}

\author{}

\date{}
\maketitle

\thispagestyle{fancy}

\tableofcontents

\section{Ресуры по языкам C и C++}

\url{https://learnc.info/c/}

\section{Указатели на функции}

\emph{Указатель} -- это переменная, содержащая \underline{\itshape адрес} другой переменной  Если одна переменная содержит {адрес} другой переменной, то говорят, что она \emph{указывает} на ту переменную\cite[\strbook{95}]{koltzov-c-lang:2019}.

Синтаксис объявления указателя
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
тип *имя_указателя;
\end{lstlisting}

\texttt{тип} -- это тип переменной, на которую будет ссылаться указатель.

Указатель, не ссылающийся на конкретную ячейку памяти, должен быть равен \emph{нулю}. Использование нулевого указателя -- это всего лишь общепринятое соглашение
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
// объявляем указатель на целочисленную переменную и инициализируем его с помощью NULL
int *p = NULL; 
\end{lstlisting}

\remark{
Указатель можно сравнивать с нулем или с \texttt{NULL}, но нельзя \texttt{NULL} сравнивать с переменной целого типа или типа с плавающей точкой \cite[\strbook{103}]{koltzov-c-lang:2019}
}

Несмотря на то, что функция \underline{не является переменной}, она располагается в памяти, и, следовательно, ее \underline{адрес} можно \emph{присваивать указателю}. Этот адрес считается точкой входа в функцию. Именно он используется при вызове. Поскольку \emph{указатель может ссылаться на функцию}, ее можно вызывать с помощью этого указателя. Это позволяет также передавать функцию другим функциям в качестве аргументов \cite{koltzov-c-lang:2019}.

\emph{Адрес функции} задается ее \emph{именем}, указанным без скобок и агрументов.

Пример
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
// Подключение заголовочных файлов с помощью инструкции препроцессора #include
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

// main - это точка входа приложения
int main() {
	char s1[10], s2[10]; // Объявление строк, как массива символов
	int (*p) (const char *, const char *); // Объявление указателя на функцию
	p = strcmp;  // Инициализация указателя; указателю присваивается адрес функции strcmp
	
	printf("Enter first string: ");
	scanf("%s", &s1);
	
	printf("Enter second string: ");
	scanf("%s", &s2);
	
	void test(
		char *x, // Указатель на символьную переменную; ожидает получить адрес
		char *y, // Указатель на символьную переменную; ожидает получить адрес
		int (*cmp) (const char *, const char *) // Указатель на функцию!
	) {
		// Сравнивает две строки
		printf("Comparation ...\n");
		if (!((*cmp)(x, y))) { // <===NB вызов функции strcmp как (*cmp)(x, y)
			printf("=> Equal!");
		} else {
			printf("=> Not equal.");
		}
	}
	
	// s1 и s2 это указатели на первый символ массива
	test(s1, s2, p);
	
	return 0;
}
\end{lstlisting}

Важный момент: \emph{имя массива} является \emph{указателем на его первый элемент} \cite[\strbook{78}]{koltzov-c-lang:2019}. То есть
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
double *p; // Объявление указателя на вещественную переменную
double total[50]; // Объявление на массив вещественных чисел двойной точности
p = total; // Указателю p присваивается адрес первого элемента массива total
\end{lstlisting}

Поэтому в функцию \texttt{test} передаются не явные адреса \texttt{\&s1} и \texttt{\&s2}, а просто имена переменных \texttt{s1} и \texttt{s2}. Ведь имена переменных \texttt{s1} и \texttt{s2} связаны со строками (по сути массивами символов), а значит имена указывают на свои первые символы и таким образом в функцию на самом деле передаются \emph{адреса первых символов этих строк}. 

\section{Коротко о стеке и куче}

Стек -- это область памяти, которую вы, как программист, не контролируете никоим образом. В нее записываются переменные и информация, которые создаются в результате вызова любых функций. Когда функция заканчивает работу, то вся информация о ее вызове и ее переменные удаляются из стека автоматически.

Куча -- это область памяти, которую контролируют непосредственно программисты.

\section{Динамическое выделение памяти}

Благодаря \emph{динамическому выделению памяти} (dynamic allocation) программа может получать необходимую ей память в ходе выполнения, а не на этапе компиляции.

В языке C есть две функции динамического выделения памяти -- \texttt{malloc()} и \texttt{calloc()}. И одна функцию освобождения памяти -- \texttt{free()}.

Память, выделяемая функциями динамического распределения, находится в куче (heap), которая представляет собой область свободной памяти, расположенную между кодом программы, сегментом данных и стеком.

Прототип функции \texttt{malloc()}
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
void *malloc(size_t количество_байтов)
\end{lstlisting}
Функция \texttt{malloc()} возвращает указатель типа \texttt{void *}. Это означает, что его можно присваивать указателю любого типа. В случае успеха функция \texttt{malloc()} возвращает \emph{указатель на первый байт памяти} (или другими словами, адрес зарезервированного участка памяти на куче), в противном случае (т.е. если размера кучи не достаточно для успешного выделения памяти) -- нулевой указатель (\texttt{NULL}).

Также полезна функция \texttt{calloc()}, позволяющая выделять память под данные конкретного типа данных
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
void *calloc(size_t num, size_t size)
\end{lstlisting}

Размер выделенной памяти будет равен величине \verb|num * size|, где \verb|size| задается в байтах.

Следующий пример выделяет 2000 байт непрерывной памяти
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
char *s; // объявление указателя на символьную переменную
s = malloc(2000);
\end{lstlisting}

После этого указатель \verb|s| будет ссылаться на первый из 2000 байт выделенной памяти.

Пример. Пусть требуется вычислить максимум в массиве, размер которого мы заранее не знаем
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main() {
	int i, num, size;
	float *data = NULL; // объявляем указатель на вещественную переменную
	
	printf("Enter number of elems: ");
	scanf("%d", &num);
	
	size = num * sizeof(float);
	
	// выделяем память
	if ((data = (float *) malloc(size)) != NULL) {
		printf("Allocated %d bytes of memory\n", size);
		// теперь с указателем data можно работать как с обычным массивом
		for (i = 0; i < num; ++i) {
			printf("Enter elem data[%d]=", i);
			scanf("%f", data + i); // `data + i` адресная арифметика
			/*
			Здесь можно было бы использовать нотацию []
			для обращения к элементам массива data, т.е.
			```
			...
			scanf("%f", &value);
			data[i] = value;
			```
			но тогда бы пришлось объявлять промежуточную переменную value;
			адресная арифметика позволяет передавать значения
			элементам массива без создания лишних переменных
			*/
		}
	} else {
		printf("Oops ...");
		exit(1);
	}
	
	for (i = 0; i < num; ++i) {
		if (*data < *(data + i)) { // значение первого элемента сравнивается с data[i]
			*data = *(data + i); // присваиваем новое значение первому элементу массива
		}
	}
	
	printf("Max(data)=%.2f", *data);
}
\end{lstlisting}

NB: оператор \verb|*| справа от символа присваивания это оператор разименования указателя (просто по адресу переменной получаем значение). А оператор \verb|*| слева от символа присваивания означает, что будет изменено значение соответствующей переменной.

\section{Функции в C}

Синтаксис объявления функции выглядит так
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
<тип> имя_функции (список_аргументов) {
    тело_функции;
}
\end{lstlisting}

Функция может возвращать переменные любого типа, \underline{\itshape кроме массива}! \cite[\strbook{109}]{koltzov-c-lang:2019}

\subsection{Параметры по ссылке и по значению}

Параметры можно передавать \emph{по ссылке} (call by reference) и \emph{по значению} (call by value) \cite[\strbook{112}]{koltzov-c-lang:2019}. В случае \emph{передачи параметра по значению} формальному параметру функции присваивается \underline{\itshape копия} значения аргумента и любые изменения копии никак не отражаются на оригинале.

Пример
\begin{lstlisting}[
title = {\sffamily Передача параметра по ЗНАЧЕНИЮ},
style = c_cpp,
numbers = none
]
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main() {
	int n = 1;
	printf("n from global: %d\n", n);  // n from global: 1
	
	int change(int a) {
		// присваивание значения переменной 'a'
		// никак не отражается на значении глобальной переменной 'n'
		a = 2;
		printf("Change = %d\n", a);  // Change = 2
		return a;
	}
	change(n);
	printf("n from global: %d", n);  // n from global: 1
}
\end{lstlisting}

При \emph{передаче параметра по ссылке} у функции есть возможность изменить значение переданного аргумента, поскольку в функцию передается не значение, а \emph{адрес} аргумента. Внутри функции этот \emph{адрес открывает доступ} к фактическому аргументу и все изменения будут отражены на аргументе.

Если нужно передавать параметры по ссылке, то указывают \verb|*| перед именем параметра. А при вызове функции нужно указать \verb|&| перед именем параметра. 

Пример
\begin{lstlisting}[
title = {\sffamily Передача параметра по ССЫЛКЕ},
style = c_cpp,
numbers = none
]
int n = 10;

printf("n from global: %d", n);  // n from global: 10

// здесь функция change ожидает получить адрес переменной!
int change(int *a) { // a -> указатель на целочисленную переменную
	// присваивание нового значения
	// по сути изменение значения переменной 'n' в глобальной области видимости
    *a = 2;  // запись
    printf("Change = %d\n", *a);  // чтение; Change = 2
    return a;
}

change(&n);  // в функцию передается АДРЕС переменной 'n'
printf("n from global: %d", n); // n from global: 2
\end{lstlisting}

Внутри функции нужно использовать оператор \verb|*| при каждом обращении к аргументу -- независимо от того, хотите ли вы \emph{прочитать} или \emph{записать} его значение \cite[\strbook{113}]{koltzov-c-lang:2019}. А в основной программе используйте \verb|&| для передачи аргументов функции.

\subsection{Передача массива в качестве параметра}

Если аргументом функции является массив, то ей передается \emph{\underline{адрес}(!) массива}. Эта ситуация представляет собой исключение из общепринятого правила передачи параметров по значению. Функция, получившая массив, получает доступ ко всем его элементам и может его модифицировать \cite[\strbook{114}]{koltzov-c-lang:2019}.

\begin{lstlisting}[
    style = c_cpp,
    numbers = none
]
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main() {
	int i, t[5];  // объявляем целочисленную переменную и массив целых чисел емкостью 5
	
	// при вызове этой функции будет передан адрес первого элемента массива 't',
	// формальный параметр следует описывать так, будть речь идет о передаче параметра по значению
	void printArray(int arr[5]) { // можно было бы описать формальный параметр как int *arr
		for (i = 0; i < 5; ++i) {
			printf("arr[%d]=%d\n", i, arr[i]);
		}
	}
	
	for (i = 0; i < 5; ++i) {
		t[i] = i * i + rand() % 10;
	}
	printArray(t);  // printArray(&t[0]);
}
\end{lstlisting}

Если в функцию передается массив, то формальный параметр функции, ожидающий массив, можно описать как \emph{обычный массив}
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
// можно не указывать размерность измерения массива,
// т.к. в С не выполняется проверка на принадлежность индекса допустимому диапазону
void printArray(int arr[]) { 
    ...
}
\end{lstlisting}
или как \emph{указатель} на переменную соответствующего типа
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
void printArray(int *arr) {
    ...
}
\end{lstlisting}

Это правило касается как числовых массивов, так и символьных.

Еще раз, как указывается в \cite[\strbook{80}]{koltzov-c-lang:2019}, размер массива, передаваемого в функцию, не имеет никакого значения, поскольку проверка выхода индекса за пределы допустимого диапазона в языке С не предусмотрена. При указании размера массива можно написать любое число -- это ничего не изменит, поскольку в функцию будет передан не массив, а \emph{лишь указатель на его первый элемент}.

При динамическом выделении памяти под массив, массив объявляется как указатель на переменную соответсвующего типа. Затем, например, с помощью функции \texttt{malloc()} резервируется участок памяти на куче. А затем с указателем можно работать как с обычными массивом -- обращаться к элементам по позиции и т.д.



% Источники в "Газовой промышленности" нумеруются по мере упоминания 
\begin{thebibliography}{99}\addcontentsline{toc}{section}{Список литературы}
	\bibitem{koltzov-c-lang:2019}{ \emph{Кольцов Д.М.} Си на примерах. Практика, практика и только практика. -- СПб.: Наука и Техника, 2019. -- 288 с.}
\end{thebibliography}

%\listoffigures\addcontentsline{toc}{section}{Список иллюстраций}

\lstlistoflistings\addcontentsline{toc}{section}{Список листингов}

\end{document}
