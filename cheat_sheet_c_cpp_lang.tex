\documentclass[%
	11pt,
	a4paper,
	utf8,
	%twocolumn
		]{article}	

\usepackage{style_packages/podvoyskiy_article_extended}


\begin{document}
\title{Приемы программирования на языках C и C++}

\author{}

\date{}
\maketitle

\thispagestyle{fancy}

\tableofcontents

\section{Указатели на функции}

\emph{Указатель} -- это переменная, содержащая \underline{\itshape адрес} другой переменной  Если одна переменная содержит {адрес} другой переменной, то говорят, что она \emph{указывает} на ту переменную\cite[\strbook{95}]{koltzov-c-lang:2019}.

Синтаксис объявления указателя
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
тип *имя_указателя;
\end{lstlisting}

\texttt{тип} -- это тип переменной, на которую будет ссылаться указатель.

Указатель, не ссылающийся на конкретную ячейку памяти, должен быть равен \emph{нулю}. Использование нулевого указателя -- это всего лишь общепринятое соглашение
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
// объявляем указатель на целочисленную переменную и инициализируем его с помощью NULL
int *p = NULL; 
\end{lstlisting}

\remark{
Указатель можно сравнивать с нулем или с \texttt{NULL}, но нельзя \texttt{NULL} сравнивать с переменной целого типа или типа с плавающей точкой \cite[\strbook{103}]{koltzov-c-lang:2019}
}

Несмотря на то, что функция \underline{не является переменной}, она располагается в памяти, и, следовательно, ее \underline{адрес} можно \emph{присваивать указателю}. Этот адрес считается точкой входа в функцию. Именно он используется при вызове. Поскольку \emph{указатель может ссылаться на функцию}, ее можно вызывать с помощью этого указателя. Это позволяет также передавать функцию другим функциям в качестве аргументов \cite{koltzov-c-lang:2019}.

\emph{Адрес функции} задается ее \emph{именем}, указанным без скобок и агрументов.

Пример
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
// Подключение заголовочных файлов с помощью инструкции препроцессора #include
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

// main - это точка входа приложения
int main() {
	char s1[10], s2[10]; // Объявление строк, как массива символов
	int (*p) (const char *, const char *); // Объявление указателя на функцию
	p = strcmp;  // Инициализация указателя; указателю присваивается адрес функции strcmp
	
	printf("Enter first string: ");
	scanf("%s", &s1);
	
	printf("Enter second string: ");
	scanf("%s", &s2);
	
	void test(
		char *x, // Указатель на символьную переменную; ожидает получить адрес
		char *y, // Указатель на символьную переменную; ожидает получить адрес
		int (*cmp) (const char *, const char *) // Указатель на функцию!
	) {
		// Сравнивает две строки
		printf("Comparation ...\n");
		if (!((*cmp)(x, y))) { // <===NB вызов функции strcmp как (*cmp)(x, y)
			printf("=> Equal!");
		} else {
			printf("=> Not equal.");
		}
	}
	
	// s1 и s2 это указатели на первый символ массива
	test(s1, s2, p);
	
	return 0;
}
\end{lstlisting}

Важный момент: \emph{имя массива} является \emph{указателем на его первый элемент} \cite[\strbook{78}]{koltzov-c-lang:2019}. То есть
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
double *p; // Объявление указателя на вещественную переменную
double total[50]; // Объявление на массив вещественных чисел двойной точности
p = total; // Указателю p присваивается адрес первого элемента массива total
\end{lstlisting}

Поэтому в функцию \texttt{test} передаются не явные адреса \texttt{\&s1} и \texttt{\&s2}, а просто имена переменных \texttt{s1} и \texttt{s2}. Ведь имена переменных \texttt{s1} и \texttt{s2} связаны со строками (по сути массивами символов), а значит имена указывают на свои первые символы и таким образом в функцию на самом деле передаются \emph{адреса первых символов этих строк}. 


% Источники в "Газовой промышленности" нумеруются по мере упоминания 
\begin{thebibliography}{99}\addcontentsline{toc}{section}{Список литературы}
	\bibitem{koltzov-c-lang:2019}{ \emph{Кольцов Д.М.} Си на примерах. Практика, практика и только практика. -- СПб.: Наука и Техника, 2019. -- 288 с.}
\end{thebibliography}

%\listoffigures\addcontentsline{toc}{section}{Список иллюстраций}

\lstlistoflistings\addcontentsline{toc}{section}{Список листингов}

\end{document}
